<?php

namespace Tests\Unit\ShopifyBulkUpload;

use App\Library\Shopify\ExcelValidator;
use Illuminate\Support\Str;
use Tests\TestCase;
use Tests\TestCaseData;

class LaravelValidatorTest extends TestCase
{
    /**
     * Function for returning string, numeric and required errors for fields.
     *
     * Function takes field name and the validation imposed on it as input and returns the error thus generated by
     * the ExcelValidator.
     *
     * @param $field_name
     * @param $field_validation
     * @return array
     */
    private function errors_per_field_validation($field_name, $field_validation)
    {
        $data = TestCaseData::DATA;
        if ($field_validation == 'required') {
            $data[$field_name] = "";
        } else if ($field_validation == 'string') {
            $data[$field_name] = 45453432;
        } else if ($field_validation == 'numeric') {
            $data[$field_name] = "TestData";
        }
        $ExcelValidator = new ExcelValidator(TestCaseData::Generate_Raw_Excel(array($data)));
        $ExcelValidator->ValidateData($ExcelValidator->FileFormattedData[0]);
        return $ExcelValidator->get_errors();
    }

    /**
     * Function for generating expected errors per field per validation rule.
     *
     * @param $fields
     * @param $validation_name
     * @return array
     */
    private function Expected_Errors($fields, $validation_name)
    {

        $errors = [];
        $attribute_error = TestCaseData::EXPECTED_ERRORS_PER_VALIDATION[$validation_name];
        $payment_no = 1;

        foreach ($fields as $field_name) {
            // For Flat fields...
            if (!Str::contains($field_name, '_' . $payment_no)) {
                $field_name = str_replace('_', ' ', $field_name);
                $error = str_replace(':attribute', $field_name, $attribute_error);
                $errors[] = $error;
            } // For Nested Fields...
            else {
                $field_name = Str::replaceFirst('_' . $payment_no, '', $field_name);
                $field_name = sprintf('payments.%s.%s', $payment_no, $field_name);
                $error = str_replace(':attribute', $field_name, $attribute_error);
                $errors[] = $error;
            }
        }
        return $errors;
    }

    /**
     * Function for returning actual errors per String, numeric and required validation rules
     *
     * @param $fields
     * @return array
     */
    private function Actual_Errors_Per_Validation($fields, $rule)
    {
        $error = "";
        $errors = [];
        foreach ($fields as $field_name) {
            if (!empty($this->errors_per_field_validation($field_name, $rule))) {
                $error = head(head($this->errors_per_field_validation($field_name, $rule)['rows']));
            }
            $errors[] = $error;
        }
        return $errors;
    }

    /**
     * Test case for checking whether valid data in all the fields asserts True or not.
     *
     * I/P - Valid data in all the fields.
     * O/P - Test case will assert True if all the validations are passed else False will be returned upon execution.
     */
    public function testValidFieldsShouldPass()
    {
        $data = array(TestCaseData::DATA);
        $ExcelValidator = new ExcelValidator(TestCaseData::Generate_Raw_Excel($data));
        $this->assertTrue($ExcelValidator->ValidateData($ExcelValidator->FileFormattedData[0]));
    }

    /**
     * Test case for checking whether all the empty fields return required error or not.
     *
     * I/P - Empty fields
     * O/P - Test case will assert True if all the actual errors match the expected errors else False.
     */
    public function testFieldRequiredErrors()
    {
        $rule = 'required';
        $expected_errors = $this->Expected_Errors(TestCaseData::REQUIRED_FIELDS, $rule);
        $actual_errors = $this->Actual_Errors_Per_Validation(TestCaseData::REQUIRED_FIELDS, $rule);
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));
    }

    /**
     * Test case for checking whether all the string fields with numeric data return string error or not.
     *
     * I/P - String type fields with numeric data
     * O/P - Test case will assert True if all the actual errors match the expected errors else False.
     */
    public function testFieldStringErrors()
    {
        $rule = 'string';
        $expected_errors = $this->Expected_Errors(TestCaseData::STRING_FIELDS, $rule);
        $actual_errors = $this->Actual_Errors_Per_Validation(TestCaseData::STRING_FIELDS, $rule);
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));
    }

    /**
     * Test case for checking whether all the numeric fields with string data return number error or not.
     *
     * I/P - Numeric type fields with string data
     * O/P - Test case will assert True if all the actual errors match the expected errors else False.
     */
    public function testFieldNumericErrors()
    {
        $rule = 'numeric';
        $expected_errors = $this->Expected_Errors(TestCaseData::NUMERIC_FIELDS, $rule);
        $actual_errors = $this->Actual_Errors_Per_Validation(TestCaseData::NUMERIC_FIELDS, $rule);
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));
    }

    /**
     * Test case for checking the regex for date of enrollment,mobile number and cheque/dd date.
     *
     * Test case will assert True if all the actual errors match the expected errors else False.
     */
    public function testRegexErrors()
    {

        $error = "";
        $actual_errors = [];
        $rule = 'regex';
        $expected_errors = $this->Expected_Errors(TestCaseData::REGEX_FIELDS, $rule);

        foreach (TestCaseData::REGEX_FIELDS as $field) {
            $data = TestCaseData::DATA;
            $data[$field] = "+9/2020%213";

            $ExcelValidator = new ExcelValidator(TestCaseData::Generate_Raw_Excel(array($data)));
            $ExcelValidator->ValidateData($ExcelValidator->FileFormattedData[0]);

            if (!empty($ExcelValidator->get_errors())) {
                $error = head(head($ExcelValidator->get_errors()['rows']));
            }
            $actual_errors[] = $error;
        }
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));
    }

    /**
     * Test case for checking the email id fields format.
     *
     *Test case will assert True if all the actual errors match the expected errors else False.
     */
    public function testEmailFormatError()
    {
        $error = "";
        $actual_errors = [];
        $rule = 'email';
        $expected_errors = $this->Expected_Errors(TestCaseData::EMAIL_FIELDS, $rule);

        foreach (TestCaseData::EMAIL_FIELDS as $field) {
            $data = TestCaseData::DATA;
            $data[$field] = "hello.com";

            $ExcelValidator = new ExcelValidator(TestCaseData::Generate_Raw_Excel(array($data)));
            $ExcelValidator->ValidateData($ExcelValidator->FileFormattedData[0]);

            if (!empty($ExcelValidator->get_errors())) {
                $error = head(head($ExcelValidator->get_errors()['rows']));
            }
            $actual_errors[] = $error;
        }
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));

    }

    /**
     * Test case for checking that whether the amount fields with errors return true or not.
     *
     * I/P - Amount fields with incorrect format
     * O/P - Test case will assert True if all the actual errors match the expected errors else False.
     */
    public function testAmountFormatError()
    {
        $error = "";
        $actual_errors = [];
        $rule = 'amount';
        $expected_errors = $this->Expected_Errors(TestCaseData::AMOUNT_FIELDS, $rule);

        foreach (TestCaseData::AMOUNT_FIELDS as $field) {
            $data = TestCaseData::DATA;
            $data[$field] = 20000.46534;

            $ExcelValidator = new ExcelValidator(TestCaseData::Generate_Raw_Excel(array($data)));
            $ExcelValidator->ValidateData($ExcelValidator->FileFormattedData[0]);

            if (!empty($ExcelValidator->get_errors())) {
                $error = head(head($ExcelValidator->get_errors()['rows']));
            }
            $actual_errors[] = $error;
        }
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));
    }

    /**
     * Test case for checking that whether the list value fields with errors return true or not.
     *
     * I/P - list value fields with the value not present in the list.
     * O/P - Test case will assert True if all the actual errors match the expected errors else False..
     */
    public function testListFields()
    {
        $error = "";
        $actual_errors = [];
        $rule = 'in';
        $expected_errors = $this->Expected_Errors(TestCaseData::RULE_IN_FIELDS, $rule);

        foreach (TestCaseData::RULE_IN_FIELDS as $field) {
            $data = TestCaseData::DATA;
            $data[$field] = 'AD';

            $ExcelValidator = new ExcelValidator(TestCaseData::Generate_Raw_Excel(array($data)));
            $ExcelValidator->ValidateData($ExcelValidator->FileFormattedData[0]);

            if (!empty($ExcelValidator->get_errors())) {
                $error = head(head($ExcelValidator->get_errors()['rows']));
            }
            $actual_errors[] = $error;
        }
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));
    }

    /**
     * Test case for checking that whether the numeric fields with exponential errors return true or not.
     *
     * I/P - Numeric fields with exponential values
     * O/P - Test case will assert True if all the actual errors match the expected errors else False.
     */
    public function testNotExponentialError()
    {
        $error = "";
        $actual_errors = [];
        $rule = 'not_exponential';
        $expected_errors = $this->Expected_Errors(TestCaseData::NOT_EXPONENTIAL_FIELDS, $rule);

        foreach (TestCaseData::NOT_EXPONENTIAL_FIELDS as $field) {
            $data = TestCaseData::DATA;
            $data[$field] = '2.3332E+13';

            $ExcelValidator = new ExcelValidator(TestCaseData::Generate_Raw_Excel(array($data)));
            $ExcelValidator->ValidateData($ExcelValidator->FileFormattedData[0]);

            if (!empty($ExcelValidator->get_errors())) {
                $error = head(head($ExcelValidator->get_errors()['rows']));
            }
            $actual_errors[] = $error;
        }
        $this->assertTrue(array_diff($expected_errors, $actual_errors) === array_diff($actual_errors, $expected_errors));
    }
}
